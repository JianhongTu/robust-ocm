"""
Visualize bounding boxes on images generated by robust_ocm.render
"""

import os
import json
import argparse
from PIL import Image, ImageDraw
from tqdm import tqdm


def visualize_bboxes_on_image(image_path, bboxes, output_path):
    """
    Draw bounding boxes on an image
    
    Args:
        image_path: Path to the original image
        bboxes: List of bounding boxes for this image, each as [x0, y0, x1, y1, text]
        output_path: Path to save the visualization
    """
    # Load image
    img = Image.open(image_path)
    draw = ImageDraw.Draw(img)
    
    # Draw each bounding box
    for i, bbox in enumerate(bboxes):
        if len(bbox) >= 5:
            x0, y0, x1, y1, text = bbox[:5]
            
            # Use different colors for different boxes (cycle through colors)
            color = f"#{i%6:02x}{(i*3)%6:02x}{(i*5)%6:02x}"
            
            # Draw rectangle
            draw.rectangle([x0, y0, x1, y1], outline=color, width=1)
            
            # Add box number for debugging (optional, for small number of boxes)
            if len(bboxes) <= 50:
                draw.text((x0 + 1, y0 + 1), str(i), fill=color)
    
    # Save visualization
    img.save(output_path)
    return output_path


def main():
    """CLI for visualizing bounding boxes"""
    parser = argparse.ArgumentParser(
        description='Visualize bounding boxes on images generated by robust_ocm.render',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Visualize all bboxes for the first 5 samples
  viz --input ./data/longbenchv2_img/line_bbox.jsonl --limit 5
  
  # Visualize specific sample
  viz --input ./data/longbenchv2_img/line_bbox.jsonl --sample-id 66fcffd9bb02136c067c94c5
  
  # Only visualize first page of each sample
  viz --input ./data/longbenchv2_img/line_bbox.jsonl --limit 5 --pages 1
        '''
    )
    
    parser.add_argument('--input',
                       required=True,
                       help='Path to processed_output.jsonl file')
    
    parser.add_argument('--image-dir',
                       help='Directory containing images (default: derived from input path)')
    
    parser.add_argument('--output-dir',
                       default='./data/longbenchv2_img/viz',
                       help='Directory to save visualizations (default: ./data/longbenchv2_img/viz)')
    
    parser.add_argument('--limit',
                       type=int,
                       default=None,
                       help='Limit processing to N samples (default: all)')
    
    parser.add_argument('--sample-id',
                       help='Process only this specific sample ID')
    
    parser.add_argument('--pages',
                       type=int,
                       default=None,
                       help='Limit to first N pages of each sample (default: all pages)')
    
    parser.add_argument('--overwrite',
                       action='store_true',
                       help='Overwrite existing visualizations')
    
    args = parser.parse_args()
    
    # Determine image directory
    if args.image_dir is None:
        # Default: assume images are in a sibling directory
        input_dir = os.path.dirname(args.input)
        args.image_dir = os.path.join(input_dir, 'images')
    
    # Check input file exists
    if not os.path.exists(args.input):
        print(f"Error: Input file not found: {args.input}")
        return 1
    
    # Check image directory exists
    if not os.path.exists(args.image_dir):
        print(f"Error: Image directory not found: {args.image_dir}")
        return 1
    
    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Read and process samples
    samples_processed = 0
    with open(args.input, 'r', encoding='utf-8') as f:
        for line_num, line in enumerate(tqdm(f, desc="Processing samples")):
            try:
                item = json.loads(line.strip())
            except json.JSONDecodeError:
                print(f"Warning: Failed to parse line {line_num + 1}")
                continue
            
            sample_id = item.get('unique_id')
            if not sample_id:
                continue
            
            # Filter by sample ID if specified
            if args.sample_id and sample_id != args.sample_id:
                continue
            
            # Get image paths and bboxes
            image_paths = item.get('image_paths', [])
            all_bboxes = item.get('bboxes', [])
            
            if not image_paths or not all_bboxes:
                print(f"Warning: No images or bboxes for sample {sample_id}")
                continue
            
            # Process each page
            pages_to_process = len(image_paths)
            if args.pages:
                pages_to_process = min(args.pages, pages_to_process)
            
            for page_idx in range(pages_to_process):
                image_path = image_paths[page_idx]
                page_bboxes = all_bboxes[page_idx] if page_idx < len(all_bboxes) else []
                
                # Get image filename
                image_filename = os.path.basename(image_path)
                
                # Create output filename
                base_name = os.path.splitext(image_filename)[0]
                viz_filename = f"{base_name}_with_bboxes.png"
                viz_path = os.path.join(args.output_dir, viz_filename)
                
                # Skip if exists and not overwriting
                if os.path.exists(viz_path) and not args.overwrite:
                    continue
                
                # Check if image exists
                if not os.path.exists(image_path):
                    print(f"Warning: Image not found: {image_path}")
                    continue
                
                # Create visualization
                try:
                    visualize_bboxes_on_image(image_path, page_bboxes, viz_path)
                except Exception as e:
                    print(f"Error visualizing {image_filename}: {e}")
                    continue
            
            samples_processed += 1
            
            # Check limit
            if args.limit and samples_processed >= args.limit:
                break
    
    print(f"\nProcessed {samples_processed} samples")
    print(f"Visualizations saved to: {args.output_dir}")
    return 0


if __name__ == '__main__':
    exit(main())